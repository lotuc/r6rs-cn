Scheme 代码的语法被组织成三个级别：

1. *lexical语法*：用于描述如何将程序文本分割成词素，
2. *datum语法*：依据lexcial语法构造，将词素序列组织成句法数据(syntactic data)，其中词法数据是递归结构的实体。
3. *程序语法*： 依据可读语法构造，更精确的定义句法数据的结构和语义。

*句法数据*（也称为外部表示，external representations）既用于表示一个对象，也用于表示该对象的记号。Scheme 的 `(rnrs io ports)` 库提供了 `get-datum` 和 `put-datum` *过程*用于读写*句法数据*，进行文本表示和对应对象值之间的转化。每个 *句法数据* 表示一个对应的*数据值(datum value)*。程序中可以使用**quote**来获得*句法数据*对应的*数据值*。

Scheme 源代码包含*句法数据*和注释。*Scheme* 中的*句法数据*被称为*句法形式*（嵌套于其它*句法形式*的 *句法形式* 被称为 *子句法形式*）。Scheme 中任何一个是 *句法形式* 的字符序列也是一个对象的 *句法数据* 表示。这使得在上下文中判断一个指定的字符序列是程序文本还是一个对象的描述可能产生疑惑。但是这是一个很强大的特性，特别是在写解释器或者编译器时，它们能将程序作为对象来处理（反之亦然）。

一个*数据值*可能有多种表示。例如 “`#e28.000`” 和 “`#x1c`” 都是整数对象 `28` 的词法表示。 “`(8 13)`”， “`( 08 13 )`”， “`(8 . (13 . ()))`” 都是同一个列表的词法表示。

由于 *词法数据* 和 *数据值* 意义相近，这份报告中 *数据* 有时既用于表示 *词法数据* 也用于表示 *数据值*，根据上下文判断它的具体含义。

Scheme 实现不可以(must not)以任何方式扩展 lexical和datum语法——存在一个例外：不需要将`<identifier>`为`r6rs`以外的`#!<identifier>`语句当作语法错误，以`#!`开头的标识符作为后续输入存在标准 lexical或datum语法的扩展的一个标志。语法 `#!r6rs` 可以被用于指明后续输入代码符合以此报告描述的 lexcial和datum语法。